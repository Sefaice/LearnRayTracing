# GPU实现---## GLSL改写CPU实现尽管用了多线程，但完全是由CPU进行计算的，而GPU有着强大很多的并行计算能力，正好目前对OpenGL比较熟悉，fragment shader可以对屏幕中每个像素进行并行计算，因此只需要把追踪的主要代码移植到fragment shader中就能实现OpenGL的光线追踪了。主函数的代码很简单，就是普通的渲染一个全屏幕的quad，在shader中利用这个quad的屏幕坐标获得该像素对应的光线，进行追踪。光线追踪的余下逻辑都在fragment shader中执行，因此那些结构体和函数也要在这里实现。由于不是实时渲染，需要对每一帧和上一帧的图像进行插值，我用了两个framebuffer交换绑定，将屏幕像素写入colorTexture，再在每次绘制时插值。接下来要实现除相机外的所有结构体和方法。由于GLSL不支持struct的内置函数，结构体的方法只能单独写作函数；GLSL没有引用，但是有inout关键字可以达到同样的效果；GLSL也不支持递归调用，只能把`Trace()`函数改写为循环形式（[参考](https://stackoverflow.com/questions/42876586/reflection-and-refraction-impossible-without-recursive-ray-tracing/45140313#45140313)）。这些改写基本都不需要改变代码逻辑，比较简单。实现后，可以发现绘制的帧率比CPU快很多，画面更好：![gpu-init](../imgs/gpu-init.PNG)### 随机数实现中需要大量用到随机数，博客中用的是[Xorshift](https://en.wikipedia.org/wiki/Xorshift)随机数，据说是最快最常用的随机数算法，但是原理我看不懂。这里用于生成32位无符号整数伪随机数：```cppstatic uint32_t XorShift32(uint32_t& state){    uint32_t x = state;    x ^= x << 13;    x ^= x >> 17;    x ^= x << 15;     state = x;    return x;}```由于这里要用的是float，需要把这个32位无符号整数转换为浮点数：```cppfloat RandomFloat01(uint32_t& state){    return (XorShift32(state) & 0xFFFFFF) / 16777216.0f;}```这里&操作将32位无符号整数抹去前8位，而16777216就是2^24，即0xFFFFFF，因此再作除法就将整数转换为0-1的浮点数了。至于为什么要用16777216.0f，这里有个答案不知是否有关系[https://stackoverflow.com/questions/12596695/why-does-a-float-variable-stop-incrementing-at-16777216-in-c](https://stackoverflow.com/questions/12596695/why-does-a-float-variable-stop-incrementing-at-16777216-in-c)。用0-1的float就可以生成高维随机数了：```cppfloat3 RandomInUnitSphere(uint32_t& state){    float3 p;    do {        p = 2.0*float3(RandomFloat01(state), RandomFloat01(state), RandomFloat01(state)) - float3(1, 1, 1);    } while (p.sqLength() >= 1.0);    return p;}```这里博客用到的乘2再减单位向量也不知所云，运行结果和直接返回`float3(RandomFloat01(state), RandomFloat01(state), RandomFloat01(state))`并没有区别。state的生成用的是：```cpp// cpuuint32_t state = (y * 9781 + data.frameCount * 6271) | 1;// d3duint state = uint(int(gl_FragCoord.x * 1973 + gl_FragCoord.y * 9277 + frameCount * 26699) | 1);// my opengluint state = uint(int(gl_FragCoord.x * time * 9781 + gl_FragCoord.y * time * 6271) | 1);```如果只是为了每一帧每次的state都不同的话，这里的写法就有很多了，第三个就是用在这里的state生成代码。### inoutRayCountGPU实现里没有统计追踪光线的次数，因为GLSL的shader若想输出变量，就只能把输出值写入color texture中，没有全局共享的变量，这样若想把每个像素追踪到光线数输出，就要为framebuffer新建texture，再在每次绘制完成后把所有数值加起来得到总的光线数，有点繁琐，因此这里性能统计就只有帧率。---